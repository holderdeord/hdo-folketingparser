#!/usr/bin/perl

use strict;
use warnings;
use utf8;

use open ':locale';

use XML::Simple;
use Data::Dumper;

my %sessionmap = (
    135 => '1989-1993',
    136 => '1989-1993',
    137 => '1989-1993',

    138 => '1993-1997',
    139 => '1993-1997',
    140 => '1993-1997',
    141 => '1993-1997',

    142 => '1997-2001',
    143 => '1997-2001',
    144 => '1997-2001',
    145 => '1997-2001',

    146 => '2001-2005',
    147 => '2001-2005',
    148 => '2001-2005',
    149 => '2001-2005',

    150 => '2005-2009',
    151 => '2005-2009',
    152 => '2005-2009',
    153 => '2005-2009',
    );

my %personmap;

sub load_votes {
    my ($filename) = @_;
    open(my $fh, "<", $filename) || die "Unable to read $filename";
    my $line = <$fh>;
    close($line);
    my @votelist;
    while ($line =~ m/^\d/) {
        my ($time, $votestr, $rest) =
            $line =~ m/^(\d{2}:\d{2}:\d{2})([MF-]+)(\d+.+)?$/;
        my @votes = split(//, $votestr);
        push @votelist, [$time, @votes];
        $line = $rest || '';
#        print "REST: '$rest'\n";
    }
    return @votelist;
}

sub load_voters_row {
    my ($entry) = @_;
    my ($region, $id, $name, $party);
    if (' ' eq substr($entry, 0, 1)) {
        ($id) = $entry =~ m/^\s+(\d+):/;
        if ($id) {
            $name = substr($entry, 6, 23);
            $party = substr($entry, 29, 6);
            $name =~ s/\s+$//;
            $party =~ s/\s+$//;
        }
    } else {
        $region = $entry;
        $region =~ s/\s+$//;
    }
    return ($region, $id, $name, $party);
}

sub load_voter {
    my ($arrayref, $region, $id, $name, $party) = @_;
    print STDERR "N: $name\n" unless defined $id;
    $arrayref->[$id] = {
        region => $region,
        name => $name,
        party => $party,
    };
}

sub load_voters {
    my ($filename) = @_;

    # Some files use Codepage 865, while others use ISO-8859-1.
    # The change happened session 144, between day 12 and day 17.
    print STDERR "Loading $filename";
    my $fileinfo = `file "$filename"`;
    my $charset;
    if ($fileinfo =~ m/Non-ISO extended-ASCII/) {
        $charset = 'CP865';
    } else {
        $charset = 'iso8859-1';
    }

    my @voter;

    open(my $fh, "<:encoding($charset)", $filename) || die "Unable to read $filename";
    my $line;
    read $fh, $line, 2;
    my ($region1, $region2);
    while (read $fh, $line, 70) {
        my $row1 = substr $line, 0, 35;
        my $row2 = substr $line, 35, 35;

        my ($region, $id, $name, $party) = load_voters_row($row1);
        $region1 = $region if ($region);
#        print STDERR "$id $name\n" if $id;
        load_voter(\@voter, $region1, $id, $name, $party) if $id;

        ($region, $id, $name, $party) = load_voters_row($row2);
        $region2 = $region if ($region);
#        print STDERR "$id $name\n" if $id;
        load_voter(\@voter, $region2, $id, $name, $party) if $id;

    }
    close($fh);
    return @voter;
}

sub load_persons {
    my ($filename) = @_;
    my $personinfo = XMLin($filename, KeyAttr => []);
    for my $person (@{$personinfo->{person}}) {
#        print Dumper($person);
        my $first_name = $person->{first_name};
        my $last_name = $person->{last_name};
        my $period = $person->{period};
        my $perid = $person->{'stortinget-perid'};

        my @list = ($last_name);
        my %variants;
        my $initials = $first_name;
        while ($initials =~ s/([A-ZÆØÅ])[\w]+(\s?)/$1.$2/) {
            my $str = "$initials $last_name";
            unless (exists $variants{$str}) {
                $variants{$str} = 1;
                push @list, $str;
            }
        }
        for my $str ( @list ) {
#            print STDERR "Mapping '$str'\n";
            my $duplicate;
            if (exists $personmap{$str}) {
                warn "error: Duplicate name string '$str'";
                $duplicate = $personmap{$str};
            } else {
                $duplicate = 0;
            }
            $personmap{$str} =
            {
                first_name => $first_name,
                last_name => $last_name,
                perid => $perid,
                duplicate => $duplicate,
                period => $period,
            };
        }
    }
}

sub find_person_from_shortname {
    my ($shortname, $session, $partyname) = @_;
    $shortname =~ s/([A-Z]\.)([A-Z])/$1 $2/g;

    # Changed name since then
    $shortname = 'K. Bekkemellem'
        if 'K. Bekkemellem Orheim' eq $shortname;

    my ($last_name) = $shortname =~ m/ (\S+)$/;
    my $first_name;
    my $perid;
    my $match = $last_name;
    if (defined $shortname && exists $personmap{$shortname}) {
        $match = $shortname;
    } elsif (defined $last_name && exists $personmap{$last_name}) {
        $match = $last_name;
    } else {
        ($last_name) = $shortname =~ m/ (\S+ \S+)$/;
        if (defined $last_name && exists $personmap{$last_name}) {
            $match = $last_name;
        } else {
            warn "error: Unable to find ID for '$shortname'";
            return undef;
        }
    }

    $perid = $personmap{$match}->{perid};
    $first_name = $personmap{$match}->{first_name};
    $last_name = $personmap{$match}->{last_name};

    if ($personmap{$match}->{duplicate}) {
        my $person = $personmap{$match};
        while ($person) {
            if ('ARRAY' eq ref $person->{period}) {
                for my $period (@{$person->{period}}) {
                    if ($partyname eq $period->{party} &&
                        $sessionmap{$session} eq $period->{content}) {
                        $perid = $person->{perid};
                        $first_name = $person->{first_name};
                        $last_name = $person->{last_name};
                        return ($perid, $first_name, $last_name);

                    }
                }
            } else {
                my $period = $person->{period};
                if ($partyname eq $period->{party} &&
                    $sessionmap{$session} eq $period->{content}) {
                    $perid = $person->{perid};
                    $first_name = $person->{first_name};
                    $last_name = $person->{last_name};
                    return ($perid, $first_name, $last_name);

                }
            }
            $person = $person->{duplicate};
        }
        warn "error: Several persons with last name $last_name (from $shortname), need better matching logic.";
        return undef;
    }

    return ($perid, $first_name, $last_name);
}

$| = 1;

load_persons('stortinget-persons-scraped.xml');

my @votefiles;
@ARGV = ('.') unless (@ARGV);
my %basenames;
for my $dir (@ARGV) {
    opendir(DIR, $dir) || die "opendir $dir failed";
    for my $filename (readdir DIR) {
        print STDERR "F: $filename\n";
        if (-f "$dir/$filename") {
            if ($filename =~ m/..\d+S\d+.*\.\d{3}$/) {
                print STDERR "V: $filename\n";
                my ($basename) = $filename =~ m/^(.+)\.\d+$/;
                $basenames{$basename}{votes} = "$dir/$filename";
            }
            if ($filename =~ m/..\d+S\d+.*\.R\d*$/) {
                print STDERR "VV: $filename\n";
                my ($basename) = $filename =~ m/^(.+)\.R\d*$/;
                $basenames{$basename}{voters} = "$dir/$filename";
            }
        }
    }
    closedir(DIR);
}
print Dumper(%basenames);

for my $basename ( keys %basenames ) {
    print "Base: $basename\n";
    my $votersfilename = $basenames{$basename}{voters};
    my $votefilename = $basenames{$basename}{votes};
    my $filelist = "'$votersfilename' '$votefilename'";
    print "Filelist: $filelist\n";

    my ($map, $id) = $basename =~ m/..(\d+)S([\d ()]+)$/;

    my ($session) = $votefilename =~ m/\.(\d{3})$/;

    my $fakeyear = 1855 + $session;
    my $date = sprintf("%4d-?-%03d", $fakeyear, $map);

    my @voter = load_voters($votersfilename);

    my @votelist = load_votes($votefilename);

    open(my $fh, ">:encoding(utf-8)", "votering-$session-$basename.xml") ||
        die "Unable to write to $basename.xml";

    print $fh <<EOF;
<?xml version="1.0" encoding="UTF-8"?>
<vote-list>
EOF

    for my $votesref (@votelist) {
        my ($time, @votes) = @{$votesref};

        print $fh <<EOF;
  <division>
    <session>$session</session>
    <when-voted>${date}T$time</when-voted>
    <map>$map</map>
    <id>$id</id>
    <description>Files: $filelist</description>
EOF

          for my $count (0 .. scalar @votes - 1) {
              my $id = $count + 1;
              my $shortname = $voter[$id]->{name};
              my $party = $voter[$id]->{party};
              my $partyname = $party;
              if (defined $party) {
                  $partyname = {
                      'A'   => 'Arbeiderpartiet',
                      'FRP' => 'Fremskrittspartiet',
                      'H'   => 'Høyre',
                      'SP'  => 'Senterpartiet',
                      'SV'  => 'Sosialistisk Venstreparti',
                      'V'   => 'Venstre',
                      'KRF' => 'Kristelig Folkeparti',
#Kystpartiet
#Norges Kommunistiske Parti
#Rød Valgallianse
#Sosialistisk Folkeparti
#Sosialistisk Valgforbund
                  }->{$party};
              } else {
                  warn "error: Missing party definition for '$party'\n" if $party;
              }
              next unless defined $shortname;

              my ($perid, $first_name, $last_name) =
                  find_person_from_shortname($shortname, $session, $partyname);
              my $vote = {F => 'yes', M=>'no', '-'=>'absent'}->{$votes[$count]};
              if (defined $perid) {
                  print $fh "    <mpname seatid=\"$id\" perid=\"$perid\" vote=\"$vote\" party=\"$partyname\">$first_name $last_name</mpname>\n";
              } else {
                  print $fh "    <mpname seatid=\"$id\" vote=\"$vote\" party=\"$partyname\">$shortname</mpname>\n";
              }
        }
        print $fh "  </division>\n";
    }
    print $fh "</vote-list>\n";
    close $fh;
}
